// src/contexts/DriveCycleContext.tsx
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useMemo,
  useCallback,
  useRef,
} from 'react';
import { fetchStatusData } from '../services/api';
import type { StatusData } from '../types/api';
import { useGlobalRefresh } from './GlobalRefreshContext';

// --- Interfaces e Constantes (sem alterações) ---
interface DriveCycleContextType {
  timeLeftSeconds: number;
  cycleDurationMinutes: number;
  displayMinutes: string;
  displaySeconds: string;
  progressPercent: number;
  isCycling: boolean;
  forceSync: () => void;
  lastSuccessfulSyncTime: string | null;
  isSyncing: boolean;
  syncError: string | null;
}

const DriveCycleContext = createContext<DriveCycleContextType | undefined>(
  undefined,
);

const DEFAULT_FALLBACK_INTERVAL_MINUTES = 15;
const POST_CYCLE_SYNC_DELAY_MS = 1000;

const STORAGE_KEYS = {
  NEXT_RUN_EPOCH: 'driveNextRunEpoch',
  INTERVAL_MINUTES: 'driveIntervalMinutes',
};

interface DriveCycleProviderProps {
  children: React.ReactNode;
}


// --- Componente Provider Modificado ---
export const DriveCycleProvider: React.FC<DriveCycleProviderProps> = ({
  children,
}) => {

  // 1. MODIFICAÇÃO: O estado inicial agora tenta ler do sessionStorage.
  const getInitialState = () => {
    const storedEpoch = sessionStorage.getItem(STORAGE_KEYS.NEXT_RUN_EPOCH);
    const storedInterval = sessionStorage.getItem(STORAGE_KEYS.INTERVAL_MINUTES);
    const now = Math.floor(Date.now() / 1000);

    const duration = storedInterval ? parseInt(storedInterval, 10) : DEFAULT_FALLBACK_INTERVAL_MINUTES;
    let timeLeft = duration * 60;

    if (storedEpoch) {
      const epoch = parseInt(storedEpoch, 10);
      if (epoch > now) {
        timeLeft = epoch - now;
      } else {
        // O tempo já passou, força uma sincronização em breve.
        timeLeft = 1;
      }
    }
    
    return {
      initialTimeLeft: timeLeft,
      initialDuration: duration
    };
  };

  const { initialTimeLeft, initialDuration } = getInitialState();

  const [cycleDurationMinutes, setCycleDurationMinutes] = useState<number>(initialDuration);
  const [timeLeftSeconds, setTimeLeftSeconds] = useState<number>(initialTimeLeft);
  const [isCycling, setIsCycling] = useState<boolean>(initialTimeLeft > 0);
  const [lastSuccessfulSync, setLastSuccessfulSync] = useState<Date | null>(null);
  const [isSyncing, setIsSyncing] = useState<boolean>(false);
  const [syncError, setSyncError] = useState<string | null>(null);
  const hasSyncedRef = useRef(false);
  const syncInProgressRef = useRef(false);
  const { tick, isRefreshing: isGlobalRefreshing } = useGlobalRefresh();

  const syncWithBackend = useCallback(async (triggeredBy?: string) => {
    // Evitar múltiplas chamadas simultâneas
    if (syncInProgressRef.current) return;
    syncInProgressRef.current = true;
    
    setIsSyncing(true);
    setSyncError(null);
    try {
      const status: StatusData = await fetchStatusData();
      hasSyncedRef.current = true;
      const nowEpochSeconds = Math.floor(Date.now() / 1000);
      let newTimeLeft = DEFAULT_FALLBACK_INTERVAL_MINUTES * 60;
      let newCycleDuration = DEFAULT_FALLBACK_INTERVAL_MINUTES;

      if (
        typeof status.driveMonitorIntervalMinutes === 'number' &&
        status.driveMonitorIntervalMinutes > 0
      ) {
        newCycleDuration = status.driveMonitorIntervalMinutes;
      }

      // Verificar se houve mudança antes de atualizar
      if (newCycleDuration !== cycleDurationMinutes) {
        setCycleDurationMinutes(newCycleDuration);
      }

      if (status.driveMonitorNextRunEpoch && status.driveMonitorNextRunEpoch > 0) {
        const calculatedTimeLeft = status.driveMonitorNextRunEpoch - nowEpochSeconds;
        newTimeLeft = Math.max(0, calculatedTimeLeft);

        // 2. MODIFICAÇÃO: Salva o estado recebido do backend no sessionStorage.
        sessionStorage.setItem(STORAGE_KEYS.NEXT_RUN_EPOCH, String(status.driveMonitorNextRunEpoch));
        sessionStorage.setItem(STORAGE_KEYS.INTERVAL_MINUTES, String(newCycleDuration));

      } else {
         // Limpa o storage se o backend não retornar dados válidos
         sessionStorage.removeItem(STORAGE_KEYS.NEXT_RUN_EPOCH);
         sessionStorage.removeItem(STORAGE_KEYS.INTERVAL_MINUTES);
      }
      
      // Verificar se houve mudança antes de atualizar
      if (newTimeLeft !== timeLeftSeconds) {
        setTimeLeftSeconds(newTimeLeft);
        setIsCycling(newTimeLeft > 0);
      }
      
      // Atualizar a última sincronização apenas se os dados mudaram
      const dataChanged = newTimeLeft !== timeLeftSeconds || newCycleDuration !== cycleDurationMinutes;
      if (dataChanged) {
        setLastSuccessfulSync(new Date());
      }

    } catch (error) {
      const errMsg = error instanceof Error ? error.message : 'Erro desconhecido ao sincronizar.';
      setSyncError(errMsg);
    } finally {
      setIsSyncing(false);
      // Liberar o bloqueio após um delay para evitar chamadas rápidas consecutivas
      setTimeout(() => {
        syncInProgressRef.current = false;
      }, 1000);
    }
  }, [cycleDurationMinutes, timeLeftSeconds]);

  const syncFnRef = useRef(syncWithBackend);
  useEffect(() => {
    syncFnRef.current = syncWithBackend;
  }, [syncWithBackend]);

  // Sincronização inicial
  useEffect(() => {
    // Usar setTimeout para garantir que a sincronização inicial aconteça após a montagem
    const timer = setTimeout(() => {
      const storedEpoch = sessionStorage.getItem(STORAGE_KEYS.NEXT_RUN_EPOCH);
      if (!storedEpoch || !hasSyncedRef.current) {
        syncFnRef.current("initialMount");
      }
    }, 200);
    return () => clearTimeout(timer);
  }, []);
  
  // Sincronizar quando o tick global mudar
  useEffect(() => {
    // Pular o primeiro tick (0) e evitar múltiplas sincronizações
    if (tick > 0 && !syncInProgressRef.current && !isGlobalRefreshing) {
      syncFnRef.current("globalRefresh");
    }
  }, [tick, isGlobalRefreshing]);

  useEffect(() => {
    if (!isCycling || timeLeftSeconds <= 0) {
      if (isCycling && timeLeftSeconds <= 0) {
        setIsCycling(false);
        // Evitar múltiplas chamadas quando o ciclo termina
        if (!syncInProgressRef.current) {
          setTimeout(() => {
            syncFnRef.current("cycleEnd");
          }, POST_CYCLE_SYNC_DELAY_MS);
        }
      }
      return;
    }

    const intervalId = setInterval(() => {
      setTimeLeftSeconds((prevTime) => Math.max(0, prevTime - 1));
    }, 1000);

    return () => clearInterval(intervalId);
  }, [timeLeftSeconds, isCycling]);

  const forceSync = useCallback(() => {
    if (!syncInProgressRef.current) {
      syncFnRef.current("forceSync");
    }
  }, []);

  const value = useMemo(() => {
    const currentCycleDurationSeconds = cycleDurationMinutes * 60;
    const progressPercent =
      currentCycleDurationSeconds > 0 && timeLeftSeconds >= 0
        ? ((currentCycleDurationSeconds - timeLeftSeconds) / currentCycleDurationSeconds) * 100
        : timeLeftSeconds <= 0 ? 100 : 0;

    return {
        timeLeftSeconds,
        cycleDurationMinutes,
        displayMinutes: String(Math.floor(timeLeftSeconds / 60)).padStart(2, '0'),
        displaySeconds: String(timeLeftSeconds % 60).padStart(2, '0'),
        progressPercent: Math.min(100, Math.max(0, progressPercent)),
        isCycling: isCycling && timeLeftSeconds > 0,
        forceSync,
        lastSuccessfulSyncTime: lastSuccessfulSync
        ? lastSuccessfulSync.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        : null,
        isSyncing,
        syncError,
 
    }
  }, [
      timeLeftSeconds, cycleDurationMinutes, isCycling, forceSync, 
      lastSuccessfulSync, isSyncing, syncError
  ]);

  return (
    <DriveCycleContext.Provider value={value}>
      {children}
    </DriveCycleContext.Provider>
  );
};

// Hook useDriveCycle (sem alterações)
export const useDriveCycle = (): DriveCycleContextType => {
  const context = useContext(DriveCycleContext);
  if (context === undefined) {
    throw new Error('useDriveCycle must be used within a DriveCycleProvider');
  }
  return context;
};