// src/contexts/FileMonitoringContext.tsx
import React, { createContext, useState, useContext, useCallback, useEffect, ReactNode, useRef } from 'react';
import { fetchFileMonitoringData } from '../services/fileMonitoringApi';
import type { FileMonitoringData, FileProcessingDetail } from '../types/fileMonitoring';
import { useNotification } from '../hooks/useNotification';
import { useGlobalRefresh } from './GlobalRefreshContext';

interface FileMonitoringContextType {
  monitoringData: FileMonitoringData | null;
  isLoading: boolean;
  error: string | null;
  lastUpdated: Date | null;
  refreshData: () => Promise<void>;
  getFileById: (fileId: string) => FileProcessingDetail | undefined;
}

const FileMonitoringContext = createContext<FileMonitoringContextType | undefined>(undefined);

export const FileMonitoringProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [monitoringData, setMonitoringData] = useState<FileMonitoringData | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  
  const { showError } = useNotification();
  const { tick, isRefreshing: isGlobalRefreshing } = useGlobalRefresh();
  const refreshInProgressRef = useRef(false);

  const refreshData = useCallback(async () => {
    // Evitar múltiplas chamadas simultâneas usando uma ref
    if (refreshInProgressRef.current) return;
    refreshInProgressRef.current = true;
    
    setIsLoading(true);
    try {
      const data = await fetchFileMonitoringData();
      // Verificar se os dados realmente mudaram antes de atualizar
      const dataChanged = JSON.stringify(data) !== JSON.stringify(monitoringData);
      
      if (dataChanged) {
        setMonitoringData(data);
        setLastUpdated(new Date());
      }
      setError(null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao buscar dados de monitoramento';
      setError(errorMessage);
      showError(errorMessage);
    } finally {
      setIsLoading(false);
      // Liberar o bloqueio após um delay para evitar chamadas rápidas consecutivas
      setTimeout(() => {
        refreshInProgressRef.current = false;
      }, 1000);
    }
  }, [showError, monitoringData]);

  const getFileById = useCallback((fileId: string): FileProcessingDetail | undefined => {
    if (!monitoringData) return undefined;
    
    return [
      ...monitoringData.activeFiles,
      ...monitoringData.recentlyCompleted,
      ...monitoringData.recentlyFailed
    ].find(file => file.fileId === fileId);
  }, [monitoringData]);

  // Carregar dados iniciais
  useEffect(() => {
    // Usar setTimeout para garantir que o carregamento inicial aconteça após a montagem
    const timer = setTimeout(() => {
      if (!refreshInProgressRef.current) {
        refreshData();
      }
    }, 100);
    return () => clearTimeout(timer);
  }, []);
  
  // Atualizar quando o tick global mudar
  useEffect(() => {
    // Pular o primeiro tick (0) e evitar atualizações durante o refresh global
    if (tick > 0 && !isGlobalRefreshing && !refreshInProgressRef.current) {
      refreshData();
    }
  }, [refreshData, tick, isGlobalRefreshing]);

  return (
    <FileMonitoringContext.Provider 
      value={{ 
        monitoringData, 
        isLoading, 
        error, 
        lastUpdated, 
        refreshData,
        getFileById
      }}
    >
      {children}
    </FileMonitoringContext.Provider>
  );
};

export const useFileMonitoring = (): FileMonitoringContextType => {
  const context = useContext(FileMonitoringContext);
  if (!context) {
    throw new Error('useFileMonitoring must be used within a FileMonitoringProvider');
  }
  return context;
};