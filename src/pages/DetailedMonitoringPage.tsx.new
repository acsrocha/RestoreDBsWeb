// src/pages/DetailedMonitoringPage.tsx
import React, { useState, useEffect, useRef } from 'react';
import { FiRefreshCw, FiClock } from 'react-icons/fi';
import FileProcessingList from '../components/monitoring/FileProcessingList';
import ErrorMessage from '../components/common/ErrorMessage';
import { useFileMonitoring } from '../contexts/FileMonitoringContext';
import { useGlobalRefresh } from '../contexts/GlobalRefreshContext';

import '../styles/components/DetailedMonitoring.css';

// Removido REFRESH_INTERVAL pois agora usamos o GlobalRefreshContext

const DetailedMonitoringPage: React.FC = () => {
  const { monitoringData, isLoading, error, lastUpdated, refreshData } = useFileMonitoring();
  const { isRefreshing: isGlobalRefreshing } = useGlobalRefresh();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const refreshInProgressRef = useRef(false);
  
  // Sincronizar o estado local de refresh com o global
  useEffect(() => {
    if (isGlobalRefreshing && !isRefreshing) {
      setIsRefreshing(true);
      // Resetar após um delay para evitar piscar
      const timer = setTimeout(() => {
        setIsRefreshing(false);
      }, 2000);
      return () => clearTimeout(timer);
    }
  }, [isGlobalRefreshing, isRefreshing]);

  // Formatar a hora da última atualização (memoizado para evitar re-renders)
  const formattedLastUpdate = React.useMemo(() => {
    return lastUpdated
      ? `${lastUpdated.getHours().toString().padStart(2, '0')}:${lastUpdated.getMinutes().toString().padStart(2, '0')}:${lastUpdated.getSeconds().toString().padStart(2, '0')}`
      : '--:--:--';
  }, [lastUpdated]);

  // Atualização automática agora é gerenciada pelo GlobalRefreshContext

  const handleManualRefresh = async () => {
    // Evitar múltiplas chamadas e verificar se já está atualizando
    if (isRefreshing || isGlobalRefreshing || refreshInProgressRef.current || isLoading) return;
    
    refreshInProgressRef.current = true;
    setIsRefreshing(true);
    
    try {
      await refreshData();
    } finally {
      // Resetar após um delay para evitar piscar
      setTimeout(() => {
        setIsRefreshing(false);
        refreshInProgressRef.current = false;
      }, 1000);
    }
  };

  return (
    <div id="view-monitoramento-detalhado" className="view active detailed-monitoring-view">
      <div className="detailed-monitoring-header">
        <h1>Monitoramento Detalhado de Arquivos</h1>
        <div className="header-actions">
          <div className="last-update">
            <FiClock className="icon" />
            <span>Última atualização: {formattedLastUpdate}</span>
          </div>
          <button 
            className="refresh-button" 
            onClick={handleManualRefresh}
            disabled={isRefreshing || isLoading || isGlobalRefreshing || refreshInProgressRef.current}
          >
            <FiRefreshCw className={isRefreshing || isGlobalRefreshing ? 'icon spinning' : 'icon'} />
            <span>Atualizar</span>
          </button>
        </div>
      </div>

      <div className="detailed-monitoring-content">
        {error && !monitoringData ? (
          <ErrorMessage 
            message={error} 
            onRetry={handleManualRefresh} 
          />
        ) : (
          <>
            <section className="monitoring-section">
              <FileProcessingList
                files={monitoringData?.activeFiles || []}
                title="Arquivos em Processamento"
                emptyMessage="Nenhum arquivo em processamento no momento"
                isLoading={isLoading && !monitoringData}
              />
            </section>

            <section className="monitoring-section">
              <FileProcessingList
                files={monitoringData?.recentlyCompleted || []}
                title="Arquivos Concluídos Recentemente"
                emptyMessage="Nenhum arquivo concluído recentemente"
                isLoading={isLoading && !monitoringData}
              />
            </section>

            <section className="monitoring-section">
              <FileProcessingList
                files={monitoringData?.recentlyFailed || []}
                title="Arquivos com Falha"
                emptyMessage="Nenhum arquivo com falha recentemente"
                isLoading={isLoading && !monitoringData}
              />
            </section>
          </>
        )}
      </div>
    </div>
  );
};

export default DetailedMonitoringPage;